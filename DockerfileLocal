# Use the pre-built base image for A0
# FROM agent-zero-base:local
FROM agent0ai/agent-zero-base:latest

# Increase HTTP timeout for uv to reduce transient download failures
ENV UV_HTTP_TIMEOUT=180

# Set BRANCH to "local" if not provided
ARG BRANCH=local
ENV BRANCH=$BRANCH
 
# Build-time toggles (kept minimal and backwards-compatible)
# SERVICE: optional service name to include specific runtime deps (e.g. memory_service)
# K8S: optional flag for k8s-tuned builds (not changing entrypoint or compose behavior)
ARG SERVICE=""
ARG K8S=false
# Torch variant controls whether torch is installed and which wheel to use:
#   none -> do not install torch
#   cpu  -> install CPU-only torch from PyTorch cpu index
#   cuda -> install CUDA-enabled torch (default if you explicitly choose cuda)
ARG TORCH_VARIANT=none

# Copy filesystem files to root
COPY ./docker/run/fs/ /
# Copy current development files to git, they will only be used in "local" branch
# Provide local sources for BRANCH=local builds (required by /ins/install_A0.sh)
COPY ./ /git/agent-zero

# pre installation steps
RUN bash /ins/pre_install.sh $BRANCH

# Prepare a dedicated venv that exposes system site packages so apt-provided wheels stay visible.
RUN apt-get update && apt-get install -y python3-venv python3-pip && \
    python3 -m venv --system-site-packages /venv && \
    /venv/bin/pip install --upgrade pip setuptools wheel && \
    apt-get clean && rm -rf /var/lib/apt/lists/* && \
    echo "export PATH=/venv/bin:\$PATH" > /etc/profile.d/venv_path.sh

# Make sure the container runtime uses the venv by default
ENV PATH="/venv/bin:${PATH}"

# install A0 (full/dev image only)
# Compatibility fix: install `pydantic-settings` into the venv so code importing BaseSettings
# (moved to pydantic-settings) can run during the install step.
RUN if [ -z "$SERVICE" ]; then \
        /venv/bin/pip install --no-cache-dir "pydantic==2.11.6" "pydantic-settings==2.6.1" && \
        TORCH_VARIANT=${TORCH_VARIANT} bash /ins/install_A0.sh $BRANCH; \
    else \
        echo "Skipping install_A0.sh for SERVICE=$SERVICE"; \
    fi

# install additional software (full/dev image only)
RUN if [ -z "$SERVICE" ]; then bash /ins/install_additional.sh $BRANCH; else echo "Skipping install_additional.sh for SERVICE=$SERVICE"; fi

# cleanup repo and install A0 without caching, this speeds up builds (full/dev image only)
ARG CACHE_DATE=none
RUN if [ -z "$SERVICE" ]; then \
        echo "cache buster $CACHE_DATE" && \
        if [ "$BRANCH" != "local" ]; then \
            TORCH_VARIANT=${TORCH_VARIANT} bash /ins/install_A02.sh $BRANCH; \
        else \
            echo "Skipping install_A02.sh for BRANCH=local"; \
        fi; \
    else \
        echo "Skipping install_A02.sh for SERVICE=$SERVICE"; \
    fi

# post installation steps (full/dev image only)
RUN if [ -z "$SERVICE" ]; then bash /ins/post_install.sh $BRANCH; else echo "Skipping post_install.sh for SERVICE=$SERVICE"; fi

# Minimal extras required at runtime but not carried in upstream requirements.
RUN /venv/bin/pip install --no-cache-dir supervisor jsonschema

# Whisper-based speech-to-text rides on torch, so only install when the torch stack is requested.
RUN if [ "${TORCH_VARIANT}" != "none" ]; then \
        /venv/bin/pip install --no-cache-dir openai-whisper || true; \
    else \
        echo "Skipping openai-whisper install (TORCH_VARIANT=${TORCH_VARIANT})"; \
    fi

# Install optional torch variant after core dependencies are in place.
RUN if [ -z "$SERVICE" ]; then \
        if [ "${TORCH_VARIANT}" = "cpu" ]; then \
            /venv/bin/pip install --no-cache-dir --extra-index-url https://download.pytorch.org/whl/cpu torch; \
        elif [ "${TORCH_VARIANT}" = "cuda" ]; then \
            /venv/bin/pip install --no-cache-dir torch; \
        else \
            echo "Skipping torch install (TORCH_VARIANT=${TORCH_VARIANT})"; \
        fi; \
    else \
        echo "Skipping torch install for SERVICE=$SERVICE"; \
    fi

# Install Playwright and its browsers for UI testing (only for full/dev image)
RUN if [ -z "$SERVICE" ]; then \
        python3 -m pip install --break-system-packages playwright && \
        python3 -m playwright install chromium && \
        python3 -m playwright install firefox && \
        python3 -m playwright install webkit; \
    else \
        echo "Skipping Playwright install for SERVICE=$SERVICE"; \
    fi

# Install asyncpg for async PostgreSQL access (memory_service and full/dev)
# Use the distribution package for the full/dev image to avoid compiling wheels on Python 3.13.
RUN if [ -z "$SERVICE" ] || [ "$SERVICE" = "settings_service" ]; then \
        apt-get update && apt-get install -y python3-asyncpg && \
        apt-get clean && rm -rf /var/lib/apt/lists/*; \
    elif [ "$SERVICE" = "memory_service" ]; then \
        apt-get update && apt-get install -y python3-asyncpg && \
        apt-get clean && rm -rf /var/lib/apt/lists/*; \
    else \
        echo "Skipping asyncpg for SERVICE=$SERVICE"; \
    fi

# Install gRPC runtime for memory service (and full/dev)
# Use the distribution package for grpc runtime to avoid building grpc C extensions in the image.
RUN if [ -z "$SERVICE" ] || [ "$SERVICE" = "memory_service" ]; then \
        apt-get update && apt-get install -y python3-grpcio && \
        apt-get clean && rm -rf /var/lib/apt/lists/*; \
    else \
        echo "Skipping grpcio for SERVICE=$SERVICE"; \
    fi

# Install per-service runtime requirements (kept minimal, optional)
# This enables single-source per-service builds without altering compose behavior.
COPY services/memory_service/requirements.txt /tmp/memory_service.requirements.txt
RUN if [ -f /tmp/memory_service.requirements.txt ] && [ "$SERVICE" = "memory_service" ]; then \
            python3 -m pip install --break-system-packages -r /tmp/memory_service.requirements.txt; \
        fi

# Expose ports
EXPOSE 22 80 9000-9009 50052

RUN chmod +x /exe/initialize.sh /exe/run_A0.sh /exe/run_searxng.sh /exe/run_tunnel_api.sh

# initialize runtime and switch to supervisord
CMD ["/exe/initialize.sh", "$BRANCH"]
