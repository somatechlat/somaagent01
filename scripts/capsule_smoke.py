"""End-to-end smoke test for the capsule registry + gateway marketplace flow.

Steps performed:
1. Build a tiny capsule zip archive on the fly (manifest + README).
2. Upload the artifact to the capsule registry via ``POST /capsules``.
3. Query the gateway ``GET /v1/capsules`` endpoint to ensure the capsule is discoverable.
4. Trigger an install through the gateway ``POST /v1/capsules/{id}/install`` endpoint (optional).

The script exits with code ``0`` on success and ``1`` when any HTTP or validation error occurs.
"""

from __future__ import annotations

import argparse
import json
import os
import sys
import tempfile
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Iterable

import httpx


@dataclass
class SmokeConfig:
    registry_url: str
    gateway_url: str
    capsule_name: str
    capsule_version: str
    description: str
    timeout: float
    skip_install: bool


def _build_args(argv: Iterable[str]) -> SmokeConfig:
    parser = argparse.ArgumentParser(description="Capsule marketplace smoke test")
    parser.add_argument(
        "--registry-url",
        default=os.getenv("CAPSULE_REGISTRY_URL", "http://localhost:8000"),
        help="Base URL for the capsule registry service (default: %(default)s)",
    )
    parser.add_argument(
        "--gateway-url",
        default=os.getenv("GATEWAY_URL", "http://localhost:8010"),
        help="Base URL for the gateway proxy (default: %(default)s)",
    )
    parser.add_argument(
        "--name",
        default=None,
        help="Capsule name to publish (default: autogenerated)",
    )
    parser.add_argument(
        "--version",
        default=None,
        help="Capsule version string (default: timestamp-based)",
    )
    parser.add_argument(
        "--description",
        default="Marketplace smoke-test capsule",
        help="Description stored alongside the capsule metadata",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=30.0,
        help="HTTP timeout in seconds (default: %(default)s)",
    )
    parser.add_argument(
        "--skip-install",
        action="store_true",
        help="Skip POST /v1/capsules/{id}/install (useful when the install path is not accessible)",
    )

    args = parser.parse_args(list(argv))
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S")
    capsule_name = args.name or f"smoke-capsule-{timestamp}"
    capsule_version = args.version or f"0.0.{timestamp}"

    return SmokeConfig(
        registry_url=args.registry_url.rstrip("/"),
        gateway_url=args.gateway_url.rstrip("/"),
        capsule_name=capsule_name,
        capsule_version=capsule_version,
        description=args.description,
        timeout=args.timeout,
        skip_install=args.skip_install,
    )


def _create_sample_capsule(temp_dir: Path, name: str, version: str, description: str) -> Path:
    capsule_zip = temp_dir / "capsule.zip"
    manifest = {
        "name": name,
        "version": version,
        "description": description,
        "generated_at": datetime.now(timezone.utc).isoformat(),
    }

    # Produce a minimal capsule with README + manifest.
    import zipfile

    with zipfile.ZipFile(capsule_zip, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        zf.writestr("manifest.json", json.dumps(manifest, indent=2))
        zf.writestr(
            "README.md",
            f"# {name}\n\nThis package was generated by the capsule smoke test at {manifest['generated_at']} UTC.\n",
        )
    return capsule_zip


def _upload_capsule(client: httpx.Client, cfg: SmokeConfig, zip_path: Path) -> dict[str, Any]:
    url = f"{cfg.registry_url}/capsules"
    with zip_path.open("rb") as fh:
        files = {"file": (zip_path.name, fh, "application/zip")}
        data = {
            "name": cfg.capsule_name,
            "version": cfg.capsule_version,
            "description": cfg.description,
        }
        response = client.post(url, data=data, files=files)
    response.raise_for_status()
    return response.json()


def _ensure_capsule_visible(
    client: httpx.Client, cfg: SmokeConfig, capsule_id: str
) -> list[dict[str, Any]]:
    url = f"{cfg.gateway_url}/v1/capsules"
    response = client.get(url)
    response.raise_for_status()
    capsules = response.json()
    if not any(item.get("id") == capsule_id for item in capsules):
        raise RuntimeError(f"Capsule {capsule_id} not returned by {url}")
    return capsules


def _trigger_install(client: httpx.Client, cfg: SmokeConfig, capsule_id: str) -> dict[str, Any]:
    url = f"{cfg.gateway_url}/v1/capsules/{capsule_id}/install"
    response = client.post(url)
    response.raise_for_status()
    return response.json()


def run_smoke(cfg: SmokeConfig) -> int:
    print("[capsule-smoke] Starting smoke test")
    with tempfile.TemporaryDirectory(prefix="capsule-smoke-") as tmp_dir:
        tmp_path = Path(tmp_dir)
        archive_path = _create_sample_capsule(
            tmp_path, cfg.capsule_name, cfg.capsule_version, cfg.description
        )
        print(f"[capsule-smoke] Created archive {archive_path}")

        with httpx.Client(timeout=cfg.timeout) as client:
            metadata = _upload_capsule(client, cfg, archive_path)
            capsule_id = metadata["id"]
            print(
                f"[capsule-smoke] Uploaded capsule {capsule_id} ({metadata['name']} v{metadata['version']})"
            )

            gateway_capsules = _ensure_capsule_visible(client, cfg, capsule_id)
            print(
                f"[capsule-smoke] Gateway reports {len(gateway_capsules)} capsule(s); new capsule is discoverable"
            )

            if cfg.skip_install:
                print("[capsule-smoke] Skipping install step as requested")
                return 0

            install_result = _trigger_install(client, cfg, capsule_id)
            install_path = install_result.get("install_path", "<unknown>")
            signature = install_result.get("signature")
            print(f"[capsule-smoke] Install succeeded → {install_path}")
            if signature:
                print(f"[capsule-smoke] Capsule signature: {signature}")

    print("[capsule-smoke] Smoke test completed successfully ✅")
    return 0


def main(argv: Iterable[str] | None = None) -> int:
    cfg = _build_args(argv or sys.argv[1:])
    try:
        return run_smoke(cfg)
    except httpx.HTTPError as exc:
        print(f"[capsule-smoke] HTTP error: {exc}", file=sys.stderr)
        return 1
    except Exception as exc:  # pragma: no cover - unexpected failure surface
        print(f"[capsule-smoke] Error: {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
